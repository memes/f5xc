package f5xc_test

import (
	_ "embed"
	"encoding/base64"
	"errors"
	"os"
	"strings"
	"testing"

	"github.com/memes/f5xc"
	"go.uber.org/goleak"
	"software.sslmate.com/src/go-pkcs12"
)

const (
	TestPKCS12CertificateFile = "testdata/test-user.p12"
	TestPKCS12Passphrase      = "insecure_passphrase"
	TestX509Certificate       = "testdata/test-user.pem"
	TestX509Key               = "testdata/test-user-key.pem"
)

//go:embed testdata/test-user.p12
var TestPKCS12CertificateContent []byte

func TestMain(m *testing.M) {
	goleak.VerifyTestMain(m)
}

// Verify that a new http.Client can be created with specific API URL endpoint.
func TestNewClient_WithAPIEndpoint(t *testing.T) {
	t.Parallel()
	tests := []struct {
		name          string
		url           string
		expectedError error
	}{
		{
			name:          "empty",
			url:           "",
			expectedError: f5xc.ErrInvalidEndpointURL,
		},
		{
			name:          "invalid-url",
			url:           "/foo/bar/baz",
			expectedError: f5xc.ErrInvalidEndpointURL,
		},
		{
			name:          "valid",
			url:           "https://f5xc.invalid/api",
			expectedError: f5xc.ErrMissingAuthentication,
		},
	}
	for _, test := range tests {
		tst := test
		t.Run(tst.name, func(t *testing.T) {
			t.Parallel()
			_, err := f5xc.NewClient(
				f5xc.WithAPIEndpoint(tst.url),
			)
			switch {
			case tst.expectedError == nil && err != nil:
				t.Errorf("NewClient raised an unexpected error: %v", err)
			case tst.expectedError != nil && !errors.Is(err, tst.expectedError):
				t.Errorf("Expected NewClient to raise %v, got %v", tst.expectedError, err)
			}
		})
	}
}

// Verify behaviour of PKCS#12 file handling.
// NOTE: Requires test certificates in testdata which can be generated by Makefile.
func TestNewClient_WithP12CertificateFile(t *testing.T) {
	t.Parallel()
	tests := []struct {
		name          string
		p12           string
		passphrase    string
		expectedError error
	}{
		{
			name:          "file-does-not-exist",
			p12:           "",
			passphrase:    "",
			expectedError: os.ErrNotExist,
		},
		{
			name:       "test-p12",
			p12:        TestPKCS12CertificateFile,
			passphrase: TestPKCS12Passphrase,
		},
		{
			name:          "invalid-passphrase",
			p12:           TestPKCS12CertificateFile,
			passphrase:    "abc",
			expectedError: pkcs12.ErrIncorrectPassword,
		},
	}
	for _, test := range tests {
		tst := test
		t.Run(tst.name, func(t *testing.T) {
			t.Parallel()
			_, err := f5xc.NewClient(
				f5xc.WithAPIEndpoint("https://f5xc.invalid/api"),
				f5xc.WithP12CertificateFile(tst.p12, tst.passphrase),
			)
			switch {
			case tst.expectedError == nil && err != nil:
				t.Errorf("NewClient raised an unexpected error: %v", err)
			case tst.expectedError != nil && !errors.Is(err, tst.expectedError):
				t.Errorf("Expected NewClient to raise %v, got %v", tst.expectedError, err)
			}
		})
	}
}

// Verify behaviour of base64 encoded PKCS#12 content handling.
// NOTE: Requires test certificates in testdata which can be generated by Makefile.
func TestNewClient_WithP12CertificateContent(t *testing.T) {
	t.Parallel()
	tests := []struct {
		name          string
		p12           string
		passphrase    string
		expectedError string
	}{
		{
			name:          "empty",
			p12:           "",
			passphrase:    "",
			expectedError: "failed to decode P12 data",
		},
		{
			name:       "test-p12",
			p12:        base64.StdEncoding.EncodeToString(TestPKCS12CertificateContent),
			passphrase: TestPKCS12Passphrase,
		},
		{
			name:          "invalid-passphrase",
			p12:           base64.StdEncoding.EncodeToString(TestPKCS12CertificateContent),
			passphrase:    "abc",
			expectedError: pkcs12.ErrIncorrectPassword.Error(),
		},
	}
	for _, test := range tests {
		tst := test
		t.Run(tst.name, func(t *testing.T) {
			t.Parallel()
			_, err := f5xc.NewClient(
				f5xc.WithAPIEndpoint("https://f5xc.invalid/api"),
				f5xc.WithP12CertificateContent(tst.p12, tst.passphrase),
			)
			switch {
			case tst.expectedError == "" && err != nil:
				t.Errorf("NewClient raised an unexpected error: %v", err)
			case tst.expectedError != "" && !strings.Contains(err.Error(), tst.expectedError):
				t.Errorf("Expected NewClient to return error containing %s, got %v", tst.expectedError, err)
			}
		})
	}
}

// Verify behaviour of PEM certificate and key handling.
// NOTE: Requires test certificates in testdata which can be generated by Makefile.
func TestNewClient_WithTestCertKeyPair(t *testing.T) {
	t.Parallel()
	tests := []struct {
		name          string
		cert          string
		key           string
		expectedError error
	}{
		{
			name:          "file-does-not-exist",
			cert:          "",
			key:           "",
			expectedError: os.ErrNotExist,
		},
		{
			name: "test-pem",
			cert: TestX509Certificate,
			key:  TestX509Key,
		},
		{
			name:          "empty-key",
			cert:          TestX509Certificate,
			key:           "",
			expectedError: os.ErrNotExist,
		},
	}
	for _, test := range tests {
		tst := test
		t.Run(tst.name, func(t *testing.T) {
			t.Parallel()
			_, err := f5xc.NewClient(
				f5xc.WithAPIEndpoint("https://f5xc.invalid/api"),
				f5xc.WithCertKeyPair(tst.cert, tst.key),
			)
			switch {
			case tst.expectedError == nil && err != nil:
				t.Errorf("NewClient raised an unexpected error: %v", err)
			case tst.expectedError != nil && !errors.Is(err, tst.expectedError):
				t.Errorf("Expected NewClient to raise %v, got %v", tst.expectedError, err)
			}
		})
	}
}
